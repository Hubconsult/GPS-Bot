import os
from dotenv import load_dotenv
import telebot
from telebot import types
from openai import OpenAI

# --- ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³: Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ Ğ¸Ğ· settings Ñ Ñ„Ğ¾Ğ»Ğ±ÑĞºĞ¾Ğ¼ Ğ½Ğ° .env ---
try:
    from settings import TOKEN, FREE_LIMIT, PAY_BUTTON_URL
except Exception:
    load_dotenv()
    TOKEN = os.getenv("BOT_TOKEN")
    FREE_LIMIT = int(os.getenv("FREE_LIMIT", "10"))
    PAY_BUTTON_URL = os.getenv("PAY_BUTTON_URL", "https://yookassa.ru/")

# --- ĞšĞ»ÑÑ‡Ğ¸ ---
load_dotenv()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

if not TOKEN:
    raise ValueError("BOT_TOKEN Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ (Ğ½Ğ¸ Ğ² settings, Ğ½Ğ¸ Ğ² .env).")
if not OPENAI_API_KEY:
    raise ValueError("OPENAI_API_KEY Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ² .env.")

bot = telebot.TeleBot(TOKEN, parse_mode="HTML")
client = OpenAI(api_key=OPENAI_API_KEY)

# --- ĞšĞ»Ğ°Ğ²Ğ¸Ğ°Ñ‚ÑƒÑ€Ñ‹ ---
def main_menu():
    kb = types.ReplyKeyboardMarkup(resize_keyboard=True, row_width=2)
    kb.add("Ğ§ĞµĞº-Ğ¸Ğ½ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ¸Ñ", "Ğ‘Ñ‹ÑÑ‚Ñ€Ğ°Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒ")
    kb.add("Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°", "ĞĞ¿Ğ»Ğ°Ñ‚Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºÑƒ")
    return kb

def pay_inline():
    ikb = types.InlineKeyboardMarkup()
    ikb.add(types.InlineKeyboardButton("ĞĞ¿Ğ»Ğ°Ñ‚Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºÑƒ â€” 299 â‚½", url=PAY_BUTTON_URL))
    return ikb

# --- ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ° ---
def check_limit(chat_id) -> bool:
    used = user_counters.get(chat_id, 0)
    if used >= FREE_LIMIT:
        bot.send_message(
            chat_id,
            "ğŸš« <b>Ğ›Ğ¸Ğ¼Ğ¸Ñ‚ Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ñ‹Ñ… Ğ´Ğ¸Ğ°Ğ»Ğ¾Ğ³Ğ¾Ğ² Ğ¸ÑÑ‡ĞµÑ€Ğ¿Ğ°Ğ½.</b>\n"
            "ĞÑ„Ğ¾Ñ€Ğ¼Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºÑƒ Ğ·Ğ° <b>299 â‚½/Ğ¼ĞµÑ.</b> ğŸ‘‡",
            reply_markup=pay_inline(),
        )
        return False
    return True

# --- GPT-5 Mini Ğ¾Ñ‚Ğ²ĞµÑ‚ ---
def gpt_answer(user_text: str) -> str:
    try:
        response = client.chat.completions.create(
            model="gpt-5-mini",
            messages=[
                {"role": "system", "content": "Ğ¢Ñ‹ â€” ĞºĞ°Ñ€Ğ¼Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¿ÑĞ¸Ñ…Ğ¾Ğ»Ğ¾Ğ³. ĞÑ‚Ğ²ĞµÑ‡Ğ°Ğ¹ Ñ‚ĞµĞ¿Ğ»Ğ¾, Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ÑÑ‰Ğµ, Ñ€Ğ°Ğ·Ğ²Ñ‘Ñ€Ğ½ÑƒÑ‚Ğ¾ Ğ¸ Ğ¿Ğ¾Ğ½ÑÑ‚Ğ½Ğ¾."},
                {"role": "user", "content": user_text}
            ]
        )
        return response.choices[0].message["content"]
    except Exception as e:
        return f"âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸Ğ¸ Ğº GPT: {e}"

# --- Ğ¥ÑĞ½Ğ´Ğ»ĞµÑ€Ñ‹ ---
@bot.message_handler(commands=["start"])
def start(m):
    user_counters[m.chat.id] = 0
    user_moods[m.chat.id] = []
    bot.send_message(
        m.chat.id,
        "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ ğŸ‘‹ Ğ¯ Ñ‚Ğ²Ğ¾Ğ¹ <b>Ğ’Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½Ğ¸Ğ¹ GPS</b>.\n\n"
        "â€¢ Ğ‘ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ğ¾ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹ <b>10 Ğ´Ğ¸Ğ°Ğ»Ğ¾Ğ³Ğ¾Ğ²</b>\n"
        "â€¢ ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑĞºĞ°: <b>299 â‚½/Ğ¼ĞµÑ.</b>\n\n"
        "Ğ’Ñ‹Ğ±Ğ¸Ñ€Ğ°Ğ¹ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:",
        reply_markup=main_menu(),
    )

@bot.message_handler(func=lambda msg: msg.text == "Ğ§ĞµĞº-Ğ¸Ğ½ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ¸Ñ")
def mood_start(m):
    if not check_limit(m.chat.id): return
    user_counters[m.chat.id] += 1
    kb = types.ReplyKeyboardMarkup(resize_keyboard=True, row_width=4, one_time_keyboard=True)
    kb.add("ğŸ˜Š", "ğŸ˜Ÿ", "ğŸ˜´", "ğŸ˜¡")
    kb.add("â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´")
    bot.send_message(m.chat.id, "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸ ÑĞ¼Ğ°Ğ¹Ğ»Ğ¸Ğº, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ±Ğ»Ğ¸Ğ¶Ğµ Ğº Ñ‚Ğ²Ğ¾ĞµĞ¼Ñƒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ:", reply_markup=kb)

@bot.message_handler(func=lambda msg: msg.text in ["ğŸ˜Š", "ğŸ˜Ÿ", "ğŸ˜´", "ğŸ˜¡"])
def mood_save(m):
    if not check_limit(m.chat.id): return
    user_counters[m.chat.id] += 1
    user_moods.setdefault(m.chat.id, []).append(m.text)
    bot.send_message(m.chat.id, f"ĞŸÑ€Ğ¸Ğ½ÑĞ» {m.text}. Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° Ğ¾Ñ‚Ğ¼ĞµÑ‚ĞºÑƒ!", reply_markup=main_menu())

@bot.message_handler(func=lambda msg: msg.text == "Ğ‘Ñ‹ÑÑ‚Ñ€Ğ°Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒ")
def quick_help(m):
    if not check_limit(m.chat.id): return
    user_counters[m.chat.id] += 1
    bot.send_message(
        m.chat.id,
        "ğŸ§­ <b>Ğ‘Ñ‹ÑÑ‚Ñ€Ğ°Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒ</b>\n"
        "â€¢ Ğ”Ñ‹Ñ…Ğ°Ğ½Ğ¸Ğµ 4-7-8\n"
        "â€¢ Ğ¢ĞµÑ…Ğ½Ğ¸ĞºĞ° Â«5 Ğ²ĞµÑ‰ĞµĞ¹ Ğ²Ğ¾ĞºÑ€ÑƒĞ³Â»\n"
        "â€¢ ĞœÑ‹ÑˆĞµÑ‡Ğ½Ğ¾Ğµ Ñ€Ğ°ÑÑĞ»Ğ°Ğ±Ğ»ĞµĞ½Ğ¸Ğµ\n",
        reply_markup=main_menu()
    )

@bot.message_handler(func=lambda msg: msg.text == "Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°")
def stats(m):
    if not check_limit(m.chat.id): return
    user_counters[m.chat.id] += 1
    moods = user_moods.get(m.chat.id, [])
    counts = {e: moods.count(e) for e in ["ğŸ˜Š", "ğŸ˜Ÿ", "ğŸ˜´", "ğŸ˜¡"]}
    bot.send_message(
        m.chat.id,
        f"ğŸ“Š <b>Ğ¢Ğ²Ğ¾Ñ Ğ½ĞµĞ´ĞµĞ»Ñ</b>\n"
        f"ğŸ˜Š Ğ Ğ°Ğ´Ğ¾ÑÑ‚ÑŒ: {counts['ğŸ˜Š']}\n"
        f"ğŸ˜Ÿ Ğ¢Ñ€ĞµĞ²Ğ¾Ğ³Ğ°: {counts['ğŸ˜Ÿ']}\n"
        f"ğŸ˜´ Ğ£ÑÑ‚Ğ°Ğ»Ğ¾ÑÑ‚ÑŒ: {counts['ğŸ˜´']}\n"
        f"ğŸ˜¡ Ğ—Ğ»Ğ¾ÑÑ‚ÑŒ: {counts['ğŸ˜¡']}",
        reply_markup=main_menu()
    )

@bot.message_handler(func=lambda msg: msg.text == "ĞĞ¿Ğ»Ğ°Ñ‚Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºÑƒ")
def pay_button(m):
    bot.send_message(
        m.chat.id,
        "ĞĞ¿Ğ»Ğ°Ñ‚Ğ° Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºĞ¸ Ñ‡ĞµÑ€ĞµĞ· Ğ®Kassa. ĞĞ°Ğ¶Ğ¼Ğ¸ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ½Ğ¸Ğ¶Ğµ ğŸ‘‡",
        reply_markup=pay_inline()
    )

@bot.message_handler(func=lambda msg: msg.text == "â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´")
def back_to_menu(m):
    bot.send_message(m.chat.id, "Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ:", reply_markup=main_menu())

# --- fallback â€” ĞµÑĞ»Ğ¸ Ñ‚ĞµĞºÑÑ‚ Ğ½Ğµ ÑĞ¾Ğ²Ğ¿Ğ°Ğ» Ñ Ğ¼ĞµĞ½Ñ, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ² GPT ---
@bot.message_handler(func=lambda msg: True)
def fallback(m):
    if not check_limit(m.chat.id): return
    user_counters[m.chat.id] += 1
    answer = gpt_answer(m.text)  # GPT-5 Mini Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°ĞµÑ‚
    bot.send_message(m.chat.id, answer, reply_markup=main_menu())

# --- Ğ—Ğ°Ğ¿ÑƒÑĞº ---
if __name__ == "__main__":
    bot.infinity_polling(skip_pending=True)


